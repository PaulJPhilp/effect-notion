#!/usr/bin/env bun
/**
 * scripts/generate-notion-schema.ts
 *
 * Optional codegen that fetches a live Notion database schema and generates
 * a static TS module under src/generated/ for compile-time typing.
 *
 * Usage:
 *   bun scripts/generate-notion-schema.ts \
 *     --databaseId <id> \
 *     [--apiKey <key>] \
 *     [--out src/generated/notion-schema.ts] \
 *     [--emitEffectSchema]
 *
 * If omitted, apiKey falls back to NOTION_API_KEY and databaseId to
 * NOTION_DATABASE_ID. Runtime discovery in NotionService remains the
 * default path; this script is optional for stricter typing needs.
 */

import "dotenv/config";
import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";

type CliOpts = {
  apiKey: string;
  databaseId: string;
  out: string;
  emitEffectSchema: boolean;
};

function parseArgs(argv: string[]): Partial<CliOpts> {
  const out: Partial<CliOpts> = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--apiKey") out.apiKey = argv[++i];
    else if (a === "--databaseId") out.databaseId = argv[++i];
    else if (a === "--out") out.out = argv[++i];
    else if (a === "--emitEffectSchema") out.emitEffectSchema = true;
  }
  return out;
}

const args = parseArgs(process.argv.slice(2));
const apiKey = args.apiKey ?? process.env.NOTION_API_KEY ?? "";
const databaseId =
  args.databaseId ?? process.env.NOTION_DATABASE_ID ?? "";
const outPath = args.out ?? "src/generated/notion-schema.ts";
const emitEffectSchema = Boolean(args.emitEffectSchema);

if (!apiKey) {
  console.error("Missing NOTION_API_KEY or --apiKey");
  process.exit(1);
}
if (!databaseId) {
  console.error("Missing NOTION_DATABASE_ID or --databaseId");
  process.exit(1);
}

async function fetchDatabaseSchema() {
  const url = `https://api.notion.com/v1/databases/${databaseId}`;
  const res = await fetch(url, {
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json",
    },
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Notion API error ${res.status}: ${body}`);
  }
  return res.json() as Promise<{
    id: string;
    last_edited_time: string;
    properties: Record<string, { type: string }>;
  }>;
}

function normalize(db: {
  id: string;
  last_edited_time: string;
  properties: Record<string, { type: string }>;
}) {
  const entries = Object.entries(db.properties).map(([name, cfg]) => ({
    name,
    type: cfg?.type ?? "unknown",
  }));
  const title = entries.find((p) => p.type === "title")?.name ?? null;
  return { entries, title } as const;
}

function genTypesModule(
  databaseId: string,
  lastEditedTime: string,
  props: ReadonlyArray<{ name: string; type: string }>,
  title: string | null,
) {
  const namesUnion = props.map((p) => `'${p.name.replace(/'/g, "\\'")}'`).join(
    " | ",
  );
  const propArray = props
    .map((p) => `  { name: '${p.name}', type: '${p.type}' as const }`)
    .join(",\n");
  const content = `// AUTO-GENERATED by scripts/generate-notion-schema.ts
// DO NOT EDIT MANUALLY. Last edited time: ${lastEditedTime}

export const generatedDatabaseId = '${databaseId}' as const;
export const generatedTitlePropertyName = ${
    title ? `'${title}' as const` : "null as const"
  };

export const generatedProperties = [
${propArray}
] as const;

export type GeneratedPropertyName = ${namesUnion || "never"};
export type GeneratedPropertyType = typeof generatedProperties[number]["type"];
export type GeneratedPropertyMap = {
  [K in GeneratedPropertyName]: Extract<
    typeof generatedProperties[number],
    { name: K }
  >["type"]
};
`;
  return content;
}

function genEffectSchemaModule(
  databaseId: string,
  lastEditedTime: string,
) {
  // Keep this minimal. The project already has a runtime DatabaseSchema; this
  // just exports a frozen metadata blob usable in tests or for asserts.
  const content = `// AUTO-GENERATED by scripts/generate-notion-schema.ts
import * as S from "effect/Schema";

export const GeneratedDatabaseMeta = S.Struct({
  databaseId: S.Literal('${databaseId}'),
  lastEditedTime: S.Literal('${lastEditedTime}')
});
`;
  return content;
}

(async () => {
  const db = await fetchDatabaseSchema();
  const { entries, title } = normalize(db);

  const outAbs = resolve(outPath);
  mkdirSync(dirname(outAbs), { recursive: true });

  const typesModule = genTypesModule(
    db.id,
    db.last_edited_time,
    entries,
    title,
  );
  writeFileSync(outAbs, typesModule, "utf8");
  console.log(`Wrote ${outPath}`);

  if (emitEffectSchema) {
    const effectOut = outPath.replace(/\.ts$/, ".effect.ts");
    const effectAbs = resolve(effectOut);
    mkdirSync(dirname(effectAbs), { recursive: true });
    const effectModule = genEffectSchemaModule(db.id, db.last_edited_time);
    writeFileSync(effectAbs, effectModule, "utf8");
    console.log(`Wrote ${effectOut}`);
  }
})();
