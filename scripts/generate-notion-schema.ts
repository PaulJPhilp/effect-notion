#!/usr/bin/env bun
/**
 * scripts/generate-notion-schema.ts
 *
 * Optional codegen that fetches a live Notion database schema and generates
 * static TS modules under src/generated/ for compile-time typing.
 *
 * Usage:
 *   bun scripts/generate-notion-schema.ts \
 *     --databaseId <id> \
 *     [--apiKey <key>] \
 *     [--out src/generated/notion-schema.ts] \
 *     [--emitEffectSchema] \
 *     [--emitDomainSchema]
 *
 * If omitted, apiKey falls back to NOTION_API_KEY and databaseId to
 * NOTION_DATABASE_ID. Runtime discovery in NotionService remains the
 * default path; this script is optional for stricter typing needs.
 */

import "dotenv/config";
import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";

type CliOpts = {
  apiKey: string;
  databaseId: string;
  out: string;
  emitEffectSchema: boolean;
  emitDomainSchema: boolean;
};

function parseArgs(argv: string[]): Partial<CliOpts> {
  const out: Partial<CliOpts> = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--apiKey") {
      out.apiKey = argv[++i];
    } else if (a === "--databaseId") {
      out.databaseId = argv[++i];
    } else if (a === "--out") {
      out.out = argv[++i];
    } else if (a === "--emitEffectSchema") {
      out.emitEffectSchema = true;
    } else if (a === "--emitDomainSchema") {
      out.emitDomainSchema = true;
    }
  }
  return out;
}

const args = parseArgs(process.argv.slice(2));
const apiKey = args.apiKey ?? process.env.NOTION_API_KEY ?? "";
const databaseId = args.databaseId ?? process.env.NOTION_DATABASE_ID ?? "";
const outPath = args.out ?? "src/generated/notion-schema.ts";
const emitEffectSchema = Boolean(args.emitEffectSchema);
const emitDomainSchema = Boolean(args.emitDomainSchema);

if (!apiKey) {
  console.error("Missing NOTION_API_KEY or --apiKey");
  process.exit(1);
}
if (!databaseId) {
  console.error("Missing NOTION_DATABASE_ID or --databaseId");
  process.exit(1);
}

// The Notion DB response includes rich property configs. Keep it loose
// so we can read select/multi_select options safely.
export type NotionDb = {
  id: string;
  last_edited_time: string;
  properties: Record<string, unknown>;
};

export async function fetchDatabaseSchema(): Promise<NotionDb> {
  const url = `https://api.notion.com/v1/databases/${databaseId}`;
  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json",
    },
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Notion API error ${res.status}: ${body}`);
  }
  return res.json() as Promise<NotionDb>;
}

export function normalize(db: NotionDb) {
  const entries = Object.entries(db.properties).map(([name, cfg]) => {
    const type =
      typeof cfg === "object" && cfg !== null && "type" in cfg
        ? (((cfg as { type?: unknown }).type as string) ?? "unknown")
        : "unknown";
    return { name, type, cfg };
  });
  const title = entries.find((p) => p.type === "title")?.name ?? null;
  return { entries, title } as const;
}

function genTypesModule(
  databaseId: string,
  lastEditedTime: string,
  props: ReadonlyArray<{ name: string; type: string }>,
  title: string | null,
) {
  const namesUnion = props
    .map((p) => `'${p.name.replace(/'/g, "\\'")}'`)
    .join(" | ");
  const propArray = props
    .map((p) => `  { name: '${p.name}', type: '${p.type}' as const }`)
    .join(",\n");
  const content = `// AUTO-GENERATED by scripts/generate-notion-schema.ts
// DO NOT EDIT MANUALLY. Last edited time: ${lastEditedTime}

export const generatedDatabaseId = '${databaseId}' as const;
export const generatedTitlePropertyName = ${
    title ? `'${title}' as const` : "null as const"
  };

export const generatedProperties = [
${propArray}
] as const;

export type GeneratedPropertyName = ${namesUnion || "never"};
export type GeneratedPropertyType = typeof generatedProperties[number]["type"];
export type GeneratedPropertyMap = {
  [K in GeneratedPropertyName]: Extract<
    typeof generatedProperties[number],
    { name: K }
  >["type"]
};
`;
  return content;
}

// --- Domain-level Effect Schema generation ---
// Build a best-effort mapping from Notion property types to Effect Schema.
// Selects and multi_selects emit literal unions from options where present.

const litUnion = (names: string[]) =>
  names.map((n) => `'${String(n).replace(/'/g, "\\'")}'`).join(", ");

function getSelectSchema(cfg: unknown): string {
  const opts =
    (
      (cfg as Record<string, unknown>)?.select as
        | { options?: Array<{ name: string }> }
        | undefined
    )?.options ?? [];
  if (opts.length > 0) {
    const lits = litUnion(opts.map((o) => o.name));
    return `S.Union(${lits.length ? `S.Literal(${lits})` : ""}, S.Undefined)`;
  }
  return "S.Union(S.String, S.Undefined)";
}

function getMultiSelectSchema(cfg: unknown): string {
  const opts =
    (
      (cfg as Record<string, unknown>)?.multi_select as
        | { options?: Array<{ name: string }> }
        | undefined
    )?.options ?? [];
  if (opts.length > 0) {
    const lits = litUnion(opts.map((o) => o.name));
    return `S.Array(S.Literal(${lits}))`;
  }
  return "S.Array(S.String)";
}

function getFormulaSchema(cfg: unknown): string {
  const ftype: string | undefined = (
    (cfg as Record<string, unknown>)?.formula as { type?: string } | undefined
  )?.type;
  if (ftype === "number") {
    return "S.Union(S.Number, S.Undefined)";
  }
  if (ftype === "string") {
    return "S.Union(S.String, S.Undefined)";
  }
  if (ftype === "boolean") {
    return "S.Union(S.Boolean, S.Undefined)";
  }
  if (ftype === "date") {
    return "S.Union(S.DateFromSelf, S.Undefined)";
  }
  return "S.Unknown";
}

function getSchemaForProperty(e: {
  name: string;
  type: string;
  cfg: unknown;
}): string {
  const t = e.type;
  const cfg = e.cfg ?? {};

  switch (t) {
    case "title":
    case "rich_text":
      return "S.String";
    case "number":
      return "S.Union(S.Number, S.Undefined)";
    case "checkbox":
      return "S.Boolean";
    case "date":
      return "S.Union(S.DateFromSelf, S.Undefined)";
    case "url":
    case "email":
      return "S.Union(S.String, S.Undefined)";
    case "files":
    case "people":
    case "relation":
      return "S.Array(S.String)";
    case "select":
      return getSelectSchema(cfg);
    case "multi_select":
      return getMultiSelectSchema(cfg);
    case "formula":
      return getFormulaSchema(cfg);
    default:
      return "S.Unknown";
  }
}

export function genDomainSchemaModule(db: NotionDb) {
  const { entries, title } = normalize(db);

  const fields: string[] = [];

  for (const e of entries) {
    const key = e.name.replace(/`/g, "`");
    const schema = getSchemaForProperty(e);
    fields.push(`  '${key}': ${schema}`);
  }

  const content = `// AUTO-GENERATED by scripts/generate-notion-schema.ts
// DO NOT EDIT MANUALLY. Database: ${db.id}

import * as S from "effect/Schema";

export const GeneratedDomain = S.Struct({
${fields.join(",\n")}
});

export type GeneratedDomain = typeof GeneratedDomain.Type;
export const generatedTitlePropertyName = ${
    title ? `'${title}' as const` : "null as const"
  };
`;
  return content;
}

function genEffectSchemaModule(databaseId: string, lastEditedTime: string) {
  // Keep this minimal. The project already has a runtime DatabaseSchema; this
  // just exports a frozen metadata blob usable in tests or for asserts.
  const content = `// AUTO-GENERATED by scripts/generate-notion-schema.ts
import * as S from "effect/Schema";

export const GeneratedDatabaseMeta = S.Struct({
  databaseId: S.Literal('${databaseId}'),
  lastEditedTime: S.Literal('${lastEditedTime}')
});
`;
  return content;
}

async function main() {
  const db = await fetchDatabaseSchema();
  const { entries, title } = normalize(db);

  const outAbs = resolve(outPath);
  mkdirSync(dirname(outAbs), { recursive: true });

  const typesModule = genTypesModule(
    db.id,
    db.last_edited_time,
    entries,
    title,
  );
  writeFileSync(outAbs, typesModule, "utf8");
  console.log(`Wrote ${outPath}`);

  if (emitEffectSchema) {
    const effectOut = outPath.replace(/\.ts$/, ".effect.ts");
    const effectAbs = resolve(effectOut);
    mkdirSync(dirname(effectAbs), { recursive: true });
    const effectModule = genEffectSchemaModule(db.id, db.last_edited_time);
    writeFileSync(effectAbs, effectModule, "utf8");
    console.log(`Wrote ${effectOut}`);
  }

  if (emitDomainSchema) {
    const domainOut = outPath.replace(
      /notion-schema\.ts$/,
      "notion-domain.schema.ts",
    );
    const domainAbs = resolve(domainOut);
    mkdirSync(dirname(domainAbs), { recursive: true });
    const domainModule = genDomainSchemaModule(db);
    writeFileSync(domainAbs, domainModule, "utf8");
    console.log(`Wrote ${domainOut}`);
  }
}

// Only run when executed directly (not when imported for tests)
if (import.meta.main) {
  main().catch((e) => {
    console.error(e);
    process.exit(1);
  });
}
